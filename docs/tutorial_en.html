

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial &mdash; yaf2q 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=01f34227"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorial(japanese)" href="tutorial_jp.html" />
    <link rel="prev" title="Introduction" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            yaf2q
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#performing-fermion-to-qubit-mappings">Performing Fermion-to-Qubit Mappings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#conventional-mapping-methods-jordan-wigner-parity-bravyi-kitaev-transformation">Conventional Mapping Methods: Jordan-Wigner, Parity, Bravyi-Kitaev transformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mapping-method-using-ternary-trees">Mapping Method Using Ternary Trees</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#optimizing-fermion-to-qubit-mappings">Optimizing Fermion-to-Qubit Mappings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_jp.html">Tutorial(japanese)</a></li>
<li class="toctree-l1"><a class="reference internal" href="yaf2q.html">yaf2q package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">yaf2q</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tutorial</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tutorial_en.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Link to this heading"></a></h1>
<p><code class="docutils literal notranslate"><span class="pre">yaf2q</span></code> is a Python library for performing fermion-to-qubit mapping used in quantum chemistry calculations. It offers two main functionalities:</p>
<ul class="simple">
<li><p><strong>Performing Fermion-to-Qubit Mappings</strong>:</p></li>
</ul>
<ul class="simple">
<li><p>It supports well-known conventional methods like the Jordan-Wigner, Parity, and Bravyi-Kitaev transformations. Additionally, it supports a more generalized approach using a Ternary Tree for describing fermion-to-qubit mappings.</p></li>
</ul>
<ul class="simple">
<li><p><strong>Optimizing Fermion-to-Qubit Mappings</strong>:</p></li>
</ul>
<ul class="simple">
<li><p>It is possible to search for a ternary tree structure that minimizes a chosen index, such as the Pauli weight in the mapped Hamiltonian, or the depth of the quantum circuit required to execute a quantum algorithm like Quantum Phase Estimation (QPE), when converting a fermionic operator to a qubit operator.</p></li>
</ul>
<p>Below is a step-by-step explanation of how to use these two functionalities.</p>
<section id="performing-fermion-to-qubit-mappings">
<h2>Performing Fermion-to-Qubit Mappings<a class="headerlink" href="#performing-fermion-to-qubit-mappings" title="Link to this heading"></a></h2>
<section id="conventional-mapping-methods-jordan-wigner-parity-bravyi-kitaev-transformation">
<h3>Conventional Mapping Methods: Jordan-Wigner, Parity, Bravyi-Kitaev transformation<a class="headerlink" href="#conventional-mapping-methods-jordan-wigner-parity-bravyi-kitaev-transformation" title="Link to this heading"></a></h3>
<p>First, import the <code class="docutils literal notranslate"><span class="pre">F2QMapper</span></code> class, which manages the fermion-to-qubit mapping:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">yaf2q.f2q_mapper</span><span class="w"> </span><span class="kn">import</span> <span class="n">F2QMapper</span>
</pre></div>
</div>
<p>You can create an instance of <code class="docutils literal notranslate"><span class="pre">F2QMapper</span></code> for the conventional mappings as follows. The constructor takes the transformation method as a string and the number of qubits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f2q_mapper</span> <span class="o">=</span> <span class="n">F2QMapper</span><span class="p">(</span><span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;jordan-wigner&quot;</span><span class="p">,</span> <span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">f2q_mapper</span> <span class="o">=</span> <span class="n">F2QMapper</span><span class="p">(</span><span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;parity&quot;</span><span class="p">,</span> <span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">f2q_mapper</span> <span class="o">=</span> <span class="n">F2QMapper</span><span class="p">(</span><span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;bravyi-kitaev&quot;</span><span class="p">,</span> <span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Printing the <code class="docutils literal notranslate"><span class="pre">f2q_mapper</span></code> (when <code class="docutils literal notranslate"><span class="pre">bravyi-kitaev</span></code> is specified) will show:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">f2q_mapper</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">named</span> <span class="n">mapper</span> <span class="o">-</span> <span class="n">bravyi</span><span class="o">-</span><span class="n">kitaev</span> <span class="p">(</span><span class="n">num_qubits</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>The fermion-to-qubit mapping matrix is stored in the <code class="docutils literal notranslate"><span class="pre">encoding_matrix</span></code> property:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">f2q_mapper</span><span class="o">.</span><span class="n">encoding_matrix</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>This matrix converts Fock states to qubit states. For example, the Fock state |1100) is represented as <code class="docutils literal notranslate"><span class="pre">[1,1,0,0]</span></code>. Applying this matrix yields <code class="docutils literal notranslate"><span class="pre">[1,0,0,0]</span></code>, corresponding to the qubit state |1000&gt;. While you can obtain the qubit state by matrix-multiplying the Fock state list, using the <code class="docutils literal notranslate"><span class="pre">fock_to_qubit_state()</span></code> method is simpler:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fock_state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">qubit_state</span> <span class="o">=</span> <span class="n">f2q_mapper</span><span class="o">.</span><span class="n">fock_to_qubit_state</span><span class="p">(</span><span class="n">fock_state</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qubit_state</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>There is also an inverse transformation method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qubit_state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">fock_state</span> <span class="o">=</span> <span class="n">f2q_mapper</span><span class="o">.</span><span class="n">qubit_to_fock_state</span><span class="p">(</span><span class="n">qubit_state</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fock_state</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>To convert a fermion operator to a qubit operator, you first create the fermion operator using a library like <a class="reference external" href="https://quantumai.google/openfermion">OpenFermion</a>. For instance, the fermion Hamiltonian for the H2 molecule can be created as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">openfermion</span><span class="w"> </span><span class="kn">import</span> <span class="n">MolecularData</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openfermionpyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">run_pyscf</span>

<span class="n">molecule</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span>
    <span class="n">geometry</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.65</span><span class="p">))],</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s2">&quot;sto-3g&quot;</span><span class="p">,</span>
    <span class="n">multiplicity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">charge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">molecule</span> <span class="o">=</span> <span class="n">run_pyscf</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="n">run_scf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">run_fci</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fermion_hamiltonian</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">get_molecular_hamiltonian</span><span class="p">()</span>
</pre></div>
</div>
<p>You can then obtain the qubit operator by passing this <code class="docutils literal notranslate"><span class="pre">fermion_hamiltonian</span></code> to the <code class="docutils literal notranslate"><span class="pre">fermion_to_qubit_operator()</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qubit_hamiltonian</span> <span class="o">=</span> <span class="n">f2q_mapper</span><span class="o">.</span><span class="n">fermion_to_qubit_operator</span><span class="p">(</span><span class="n">fermion_hamiltonian</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">qubit_hamiltonian</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">yaf2q</span></code>’s <code class="docutils literal notranslate"><span class="pre">QubitOperatorSet</span></code> class, which stores OpenFermion <code class="docutils literal notranslate"><span class="pre">QubitOperator</span></code> or qiskit <code class="docutils literal notranslate"><span class="pre">SparsePauliOp</span></code> objects. These can be accessed via the <code class="docutils literal notranslate"><span class="pre">openfermion_form</span></code> and <code class="docutils literal notranslate"><span class="pre">qiskit_form</span></code> properties, respectively:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">openfermion_form</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">0.03775110394645509</span> <span class="p">[]</span> <span class="o">+</span>
<span class="mf">0.04407961290255181</span> <span class="p">[</span><span class="n">X0</span> <span class="n">Z1</span> <span class="n">X2</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.04407961290255181</span> <span class="p">[</span><span class="n">X0</span> <span class="n">Z1</span> <span class="n">X2</span> <span class="n">Z3</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.04407961290255181</span> <span class="p">[</span><span class="n">Y0</span> <span class="n">Z1</span> <span class="n">Y2</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.04407961290255181</span> <span class="p">[</span><span class="n">Y0</span> <span class="n">Z1</span> <span class="n">Y2</span> <span class="n">Z3</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.18601648886230604</span> <span class="p">[</span><span class="n">Z0</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.18601648886230604</span> <span class="p">[</span><span class="n">Z0</span> <span class="n">Z1</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.1699209784826151</span> <span class="p">[</span><span class="n">Z0</span> <span class="n">Z1</span> <span class="n">Z2</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.1699209784826151</span> <span class="p">[</span><span class="n">Z0</span> <span class="n">Z1</span> <span class="n">Z2</span> <span class="n">Z3</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.12584136558006329</span> <span class="p">[</span><span class="n">Z0</span> <span class="n">Z2</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.12584136558006329</span> <span class="p">[</span><span class="n">Z0</span> <span class="n">Z2</span> <span class="n">Z3</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.17297610130745106</span> <span class="p">[</span><span class="n">Z1</span><span class="p">]</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.26941693141631995</span> <span class="p">[</span><span class="n">Z1</span> <span class="n">Z2</span> <span class="n">Z3</span><span class="p">]</span> <span class="o">+</span>
<span class="mf">0.17866777775953394</span> <span class="p">[</span><span class="n">Z1</span> <span class="n">Z3</span><span class="p">]</span> <span class="o">+</span>
<span class="o">-</span><span class="mf">0.26941693141631995</span> <span class="p">[</span><span class="n">Z2</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">qiskit_form</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SparsePauliOp</span><span class="p">([</span><span class="s1">&#39;IIII&#39;</span><span class="p">,</span> <span class="s1">&#39;IIZI&#39;</span><span class="p">,</span> <span class="s1">&#39;IZII&#39;</span><span class="p">,</span> <span class="s1">&#39;IZIZ&#39;</span><span class="p">,</span> <span class="s1">&#39;IZZZ&#39;</span><span class="p">,</span> <span class="s1">&#39;XZXI&#39;</span><span class="p">,</span> <span class="s1">&#39;XZXZ&#39;</span><span class="p">,</span> <span class="s1">&#39;YZYI&#39;</span><span class="p">,</span> <span class="s1">&#39;YZYZ&#39;</span><span class="p">,</span> <span class="s1">&#39;ZIII&#39;</span><span class="p">,</span> <span class="s1">&#39;ZIZI&#39;</span><span class="p">,</span> <span class="s1">&#39;ZIZZ&#39;</span><span class="p">,</span> <span class="s1">&#39;ZZII&#39;</span><span class="p">,</span> <span class="s1">&#39;ZZZI&#39;</span><span class="p">,</span> <span class="s1">&#39;ZZZZ&#39;</span><span class="p">],</span> 
	<span class="n">coeffs</span><span class="o">=</span><span class="p">[</span> <span class="mf">0.0377511</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.26941693</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.1729761</span> <span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.17866778</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.26941693</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.04407961</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.04407961</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.04407961</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.04407961</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.18601649</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.12584137</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.12584137</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.18601649</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.16992098</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span>  <span class="mf">0.16992098</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">QubitOperatorSet</span></code> class also has methods for calculating eigenvalues and eigenvectors. The <code class="docutils literal notranslate"><span class="pre">eigenvalues()</span></code> method returns a list of the <code class="docutils literal notranslate"><span class="pre">num</span></code> smallest eigenvalues:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">num</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, <code class="docutils literal notranslate"><span class="pre">eigenvectors()</span></code> returns a list of the <code class="docutils literal notranslate"><span class="pre">num</span></code> corresponding eigenvectors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">(</span><span class="n">num</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain both eigenvalues and eigenvectors simultaneously, use the <code class="docutils literal notranslate"><span class="pre">eigsh()</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span class="n">num</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also a <code class="docutils literal notranslate"><span class="pre">pauli_weights()</span></code> method that returns a list of Pauli weights:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">pauli_weights</span><span class="p">())</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>This list can be used to calculate statistics like the average, maximum, or minimum Pauli weight.</p>
</section>
<section id="mapping-method-using-ternary-trees">
<h3>Mapping Method Using Ternary Trees<a class="headerlink" href="#mapping-method-using-ternary-trees" title="Link to this heading"></a></h3>
<p>A Ternary Tree is generally a tree structure where each node has at most three children. However, for fermion-to-qubit mappings, a specific type of Ternary Tree is used, as illustrated below.</p>
<p><img alt="ternary_tree_1" src="_images/ternary_tree_1.png" /></p>
<p>In this diagram, nodes are represented by ellipses with their numbers inside. Edges emanating from a node are labeled X, Y, or Z, corresponding to Pauli X, Y, and Z operators, respectively. Unlike general Ternary Trees, edges may not lead to a child node. For details, refer to the paper:<a class="reference external" href="https://arxiv.org/abs/2505.06212">”From fermions to Qubits: A ZX-Calculus Perspective”</a>. The key takeaway is that any fermion-to-qubit mapping can be defined by such a Ternary Tree, and the transformation algorithm is known.</p>
<p>To define a Ternary Tree in <code class="docutils literal notranslate"><span class="pre">yaf2q</span></code>, use the <code class="docutils literal notranslate"><span class="pre">TernaryTreeSpec</span></code> class. Its constructor takes <code class="docutils literal notranslate"><span class="pre">indices</span></code> and <code class="docutils literal notranslate"><span class="pre">edges</span></code> arguments:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">yaf2q.ternary_tree_spec</span><span class="w"> </span><span class="kn">import</span> <span class="n">TernaryTreeSpec</span>

<span class="n">ttspec</span> <span class="o">=</span> <span class="n">TernaryTreeSpec</span><span class="p">(</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">)},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">indices</span></code> is a list of node numbers, defining a Ternary Tree with four nodes. <code class="docutils literal notranslate"><span class="pre">edges</span></code> represents the set of edges. The keys are child node numbers, and the values are tuples <code class="docutils literal notranslate"><span class="pre">(parent_node_number,</span> <span class="pre">edge_label)</span></code>. The root node is assumed to be 0. Child node numbers do not include 0, parent node numbers are always smaller than child node numbers, and edge tuples must be unique. This uniquely defines the Ternary Tree structure.</p>
<p>You can visualize the Ternary Tree using <code class="docutils literal notranslate"><span class="pre">ttspec.show()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ttspec</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This will display the Ternary Tree diagram.</p>
<p>If you want to define a Ternary Tree with the same structure but different node numbering, you can reorder the <code class="docutils literal notranslate"><span class="pre">indices</span></code> list. Do not change <code class="docutils literal notranslate"><span class="pre">edges</span></code>, as this would alter the tree’s shape.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ttspec</span> <span class="o">=</span> <span class="n">TernaryTreeSpec</span><span class="p">(</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">)},</span>
<span class="p">)</span>
<span class="n">ttspec</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This generates a Ternary Tree with only the node numbers changed:</p>
<p><img alt="ternary_tree_2" src="_images/ternary_tree_2.png" /></p>
<p>You can also generate a random Ternary Tree without explicitly specifying <code class="docutils literal notranslate"><span class="pre">indices</span></code> and <code class="docutils literal notranslate"><span class="pre">edges</span></code> using the <code class="docutils literal notranslate"><span class="pre">random()</span></code> class method, which takes the number of nodes as an argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ttspec</span> <span class="o">=</span> <span class="n">TernaryTreeSpec</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ttspec</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indices</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">:{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once you have a Ternary Tree, you can create an <code class="docutils literal notranslate"><span class="pre">F2QMapper</span></code> instance based on it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f2q_mapper</span> <span class="o">=</span> <span class="n">F2QMapper</span><span class="p">(</span><span class="n">ttspec</span><span class="o">=</span><span class="n">ttspec</span><span class="p">)</span>
</pre></div>
</div>
<p>From this point, you can obtain qubit states, qubit operators, and their corresponding eigenvalues, eigenvectors, and Pauli weights, just as described in the “Conventional Mapping Methods” section.</p>
</section>
</section>
<section id="optimizing-fermion-to-qubit-mappings">
<h2>Optimizing Fermion-to-Qubit Mappings<a class="headerlink" href="#optimizing-fermion-to-qubit-mappings" title="Link to this heading"></a></h2>
<p>Next, let’s discuss the optimization of fermion-to-qubit mappings.</p>
<p>Consider a 1D chain of four hydrogen atoms and aim to find a fermion-to-qubit mapping (i.e., a Ternary Tree) that minimizes the average Pauli weight of the resulting qubit Hamiltonian. First, create the fermion Hamiltonian using OpenFermion:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">openfermion</span><span class="w"> </span><span class="kn">import</span> <span class="n">MolecularData</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openfermionpyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">run_pyscf</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">yaf2q.ternary_tree_spec</span><span class="w"> </span><span class="kn">import</span> <span class="n">TernaryTreeSpec</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">yaf2q.f2q_mapper</span><span class="w"> </span><span class="kn">import</span> <span class="n">F2QMapper</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">yaf2q.optimizer.sa</span><span class="w"> </span><span class="kn">import</span> <span class="n">SAParams</span><span class="p">,</span> <span class="n">SA</span>

<span class="n">distance</span> <span class="o">=</span> <span class="mf">0.65</span>
<span class="n">molecule</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span>
    <span class="n">geometry</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">distance</span><span class="p">)),</span> <span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">distance</span><span class="p">))],</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span>
    <span class="n">multiplicity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">charge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">molecule</span> <span class="o">=</span> <span class="n">run_pyscf</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="n">run_scf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">run_fci</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fermion_hamiltonian</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">get_molecular_hamiltonian</span><span class="p">()</span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="n">fermion_hamiltonian</span><span class="o">.</span><span class="n">one_body_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Define an objective function that takes a <code class="docutils literal notranslate"><span class="pre">TernaryTreeSpec</span></code> and returns a float (e.g., the average Pauli weight). This should be defined as an inner function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">objective_func</span><span class="p">(</span><span class="n">ttspec</span><span class="p">:</span> <span class="n">TernaryTreeSpec</span><span class="p">):</span>
    <span class="n">f2q_mapper</span> <span class="o">=</span> <span class="n">F2QMapper</span><span class="p">(</span><span class="n">ttspec</span><span class="o">=</span><span class="n">ttspec</span><span class="p">)</span>
    <span class="n">qubit_hamiltonian</span> <span class="o">=</span> <span class="n">f2q_mapper</span><span class="o">.</span><span class="n">fermion_to_qubit_operator</span><span class="p">(</span><span class="n">fermion_hamiltonian</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">pauli_weights</span><span class="p">()</span>
    <span class="n">weight_ave</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weight_ave</span>
</pre></div>
</div>
<p>This function calculates the average Pauli weight. You can define any function that takes <code class="docutils literal notranslate"><span class="pre">TernaryTreeSpec</span></code> and returns a float. For example, you could calculate the depth of a quantum circuit for Quantum Phase Estimation and aim to minimize that.</p>
<p>With the objective function defined, you can use <code class="docutils literal notranslate"><span class="pre">yaf2q</span></code>’s <code class="docutils literal notranslate"><span class="pre">SA</span></code> class (Simulated Annealing) to find a solution that minimizes it. The <code class="docutils literal notranslate"><span class="pre">SA</span></code> constructor takes the number of qubits, the objective function, parameters (<code class="docutils literal notranslate"><span class="pre">SAParams</span></code>), and a verbose flag:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ttspec_opt</span> <span class="o">=</span> <span class="n">SA</span><span class="p">(</span>
        <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">num_qubits</span><span class="p">,</span>
        <span class="n">objective_func</span> <span class="o">=</span> <span class="n">objective_func</span><span class="p">,</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">SAParams</span><span class="p">(</span><span class="n">init_sampling</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">cooling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">),</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">SAParams</span></code> object controls the simulated annealing process with parameters like <code class="docutils literal notranslate"><span class="pre">init_sampling</span></code> (number of initial random samples), <code class="docutils literal notranslate"><span class="pre">num_steps</span></code> (number of annealing steps), and <code class="docutils literal notranslate"><span class="pre">cooling_factor</span></code> (how rapidly the temperature decreases). Default values are <code class="docutils literal notranslate"><span class="pre">init_sampling=10</span></code>, <code class="docutils literal notranslate"><span class="pre">num_steps=10</span></code>, and <code class="docutils literal notranslate"><span class="pre">cooling_factor=1.0</span></code>. Adjusting these parameters may be necessary for optimal convergence.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">optimize()</span></code> method then executes the optimization to find an (approximately) optimal ternary tree (<code class="docutils literal notranslate"><span class="pre">ttspec_opt</span></code>).</p>
<p>Finally, use <code class="docutils literal notranslate"><span class="pre">ttspec_opt</span></code> to perform the fermion-to-qubit mapping and display the resulting qubit operator and Pauli weights:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;* ternary tree:</span><span class="se">\n</span><span class="si">{</span><span class="n">ttspec_opt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">f2q_mapper</span> <span class="o">=</span> <span class="n">F2QMapper</span><span class="p">(</span><span class="n">ttspec</span><span class="o">=</span><span class="n">ttspec_opt</span><span class="p">)</span>
<span class="n">qubit_hamiltonian</span> <span class="o">=</span> <span class="n">f2q_mapper</span><span class="o">.</span><span class="n">fermion_to_qubit_operator</span><span class="p">(</span><span class="n">fermion_hamiltonian</span><span class="p">)</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">pauli_weights</span><span class="p">()</span>
<span class="n">weight_ave</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;* pauli weight (ave): </span><span class="si">{</span><span class="n">weight_ave</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Example output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">jordan</span><span class="o">-</span><span class="n">wigner</span><span class="p">]</span>
<span class="o">*</span> <span class="n">pauli</span> <span class="n">wieght</span> <span class="p">(</span><span class="n">ave</span><span class="p">):</span> <span class="mf">4.583783783783784</span>
<span class="p">[</span><span class="n">parity</span><span class="p">]</span>
<span class="o">*</span> <span class="n">pauli</span> <span class="n">weight</span> <span class="p">(</span><span class="n">ave</span><span class="p">):</span> <span class="mf">4.691891891891892</span>
<span class="p">[</span><span class="n">bravyi</span><span class="o">-</span><span class="n">kitaev</span><span class="p">]</span>
<span class="o">*</span> <span class="n">pauli</span> <span class="n">weight</span> <span class="p">(</span><span class="n">ave</span><span class="p">):</span> <span class="mf">4.562162162162162</span>
<span class="p">[</span><span class="n">ternary</span> <span class="n">tree</span> <span class="n">optimization</span><span class="p">]</span>
<span class="o">*</span> <span class="n">ternary</span> <span class="n">tree</span><span class="p">:</span>
<span class="n">indices</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">edges</span><span class="p">:{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span> <span class="mi">4</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span> <span class="mi">5</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">),</span> <span class="mi">6</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">),</span> <span class="mi">7</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="o">*</span> <span class="n">pauli</span> <span class="n">product</span> <span class="n">length</span> <span class="p">(</span><span class="n">ave</span><span class="p">):</span> <span class="mf">4.4324324324324325</span>
</pre></div>
</div>
<p>The optimized Ternary Tree shows a smaller average Pauli weight compared to the conventional methods.</p>
<p>Since simulated annealing is a stochastic method, the results of the ternary tree optimization will vary. You can fix the random seed for reproducible results:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ttspec_opt</span> <span class="o">=</span> <span class="n">SA</span><span class="p">(</span>
        <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">num_qubits</span><span class="p">,</span>
        <span class="n">objective_func</span> <span class="o">=</span> <span class="n">objective_func</span><span class="p">,</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">SAParams</span><span class="p">(</span><span class="n">init_sampling</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">cooling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">),</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="introduction.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tutorial_jp.html" class="btn btn-neutral float-right" title="Tutorial(japanese)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Sam.N.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>